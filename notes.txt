

building on WSL:Ubuntu

sudo apt install libcurl4-openssl-dev
sudo apt update && sudo apt upgrade
sudo apt install g++ gdb make
sudo apt install gcc-arm-none-eabi


-- Could NOT find PkgConfig (missing: PKG_CONFIG_EXECUTABLE) 
-- Could NOT find ALSA (missing: ALSA_LIBRARY ALSA_INCLUDE_DIR) 
-- Could NOT find X11 (missing: X11_X11_INCLUDE_PATH X11_X11_LIB) 
-- Could NOT find OpenGL (missing: OPENGL_opengl_LIBRARY OPENGL_glx_LIBRARY OPENGL_INCLUDE_DIR) 
-- 
-- SDL3 was configured with the following options:
-- 
-- Platform: Linux-5.15.133.1-microsoft-standard-WSL2
-- 64-bit:   TRUE
-- Compiler: /usr/bin/cc
-- Revision: SDL-prerelease-3.0.0-3006-ged3fad188
-- Vendor:   






## Window manager evaluation

### SDL 3

* no display names
* patchable CVDisplayLink support for MacOS
* reports 1x and 2x pixel densities per video mode

### GLFW 3

* correct monitor names
* no CVDisplayLink support
* no pixel density encoded in video mode






flat no interpolation variables

- do not apply to inputs into a vertex shader or outputs from a fragment shader





//		float identity[] = {1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0 ,0.0,0.0,0.0,1.0};
//		setMatrix(view, identity);



if(MSVC)
  target_compile_options(<target> PUBLIC "/ZI")
  target_link_options(<target> PUBLIC "/INCREMENTAL")
endif()



		// vbo - vertex buffer - 

		// The attribute qualifier can be used only with the data types float, vec2, vec3, vec4, mat2, mat3, and mat4.

		// glEnableVertexAttribArray uses currently bound vertex array object for the operation, 
		// whereas glEnableVertexArrayAttrib updates state of the vertex array object with ID vaobj.

//		glEnableVertexArrayAttrib(vao, attribute);

//		glVertexAttribPointer(index, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
//		glVertexAttribPointer(index, 4, GL_INT, GL_FALSE, 4 * sizeof(int), (void*)0);

//		glVertexAttribPointer(attribute, 4, GL_FLOAT, GL_FALSE, 0, 0);


	// The attribute qualifier can be used only with the data types float, vec2, vec3, vec4, mat2, mat3, and mat4.


	void bufferFloatQuads(i32 attribute, float *vertices, int count) {
//		glBindVertexArray(vao);
		int index = attribute;
		int dim = 4; // size in components, 1,2,3 or 4
		int offset = 0;
		int stride = 0; // tightly packed
		void* pointer = 0;
//		glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
//		glEnableVertexAttribArray(0);
//		glVertexAttribPointer(index, dim, GL_FLOAT, GL_FALSE, stride, pointer);
		glBufferData(GL_ARRAY_BUFFER, count * 16, vertices, GL_DYNAMIC_DRAW);
	}


//		glUseProgram(shaderProgram);
//		glBindVertexArray(vao);
//		glDrawArrays(GL_TRIANGLES, 0, 4);



#version 410

uniform mat4 view;
uniform vec4 palette[16];
uniform ivec4 style[16];
uniform mat4 handles[32];

in ivec4 xyzc;
out vec4 color;

void main(){
	int w=int(xyzc.w);
	color=palette[w&15];
	mat4 model=handles[0];
	vec4 v=vec4(xyzc.x,xyzc.y,xyzc.z,1.0);
	v=v*model;
	v=v*view;
	float zbias=0.0;
	float d=zbias+v.z;
	vec4 i=vec4(v.x,v.y,d,1.0);
	gl_Position=i;
}



//#include <SDL3/SDL_opengl.h>

=======
https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.10.pdf

/*

	* display device management courtesy SDL3 
	* OpenGL bindings courtesy Glad Loader-Generator 
	* SDL_CocoaOpenGL movedToNewScreen patch courtesy Simon Armstrong

*/

- (void)movedToNewScreen
{
    if (self->displayLink) {
        SDL_CocoaWindowData *windowData = (__bridge SDL_CocoaWindowData *)self->window->driverdata;
        NSScreen *screen = [[windowData nswindow] screen];
        const CGDirectDisplayID displayID = [[screen.deviceDescription objectForKey:@"NSScreenNumber"] unsignedIntValue];
        int success2 = CVDisplayLinkSetCurrentCGDisplay(self->displayLink, displayID);

        if( success2 == kCVReturnSuccess ){
            NSLog(@"movedToNewScreen CVDisplayLinkSetCurrentCGDisplay Success displayID = %i",displayID);
        }else{
            NSLog(@"movedToNewScreen CVDisplayLinkSetCurrentCGDisplay Fail");
        }
/*
        int success = CVDisplayLinkSetCurrentCGDisplayFromOpenGLContext(self->displayLink, [self CGLContextObj], [[self openglPixelFormat] CGLPixelFormatObj]);
        if(success==kCVReturnSuccess){
            NSLog(@"movedToNewScreen CVDisplayLink Success");
        }else{
            NSLog(@"movedToNewScreen CVDisplayLink Fail");
        }
*/
    }
}

//
// GL version
//
// see SDL_cocoaopengl - (void)movedToNewScreen
//
// theory: a new GL context is required to observe monitor refresh rate when dragging window to external monitor
//
// https://discourse.libsdl.org/t/sdl-cocoa-update-cvdisplaylink-timing-when-screen-changes/39804
//


CVDisplayLinkSetCurrentCGDisplay patch for SDL_cocoaopengl movedToNewScreen

- (void)movedToNewScreen
{
    if (self->displayLink) {
        SDL_CocoaWindowData *windowData = (__bridge SDL_CocoaWindowData *)self->window->driverdata;
        NSScreen *screen = [[windowData nswindow] screen];
        const CGDirectDisplayID displayID = [[screen.deviceDescription objectForKey:@"NSScreenNumber"] unsignedIntValue];

        int success2 = CVDisplayLinkSetCurrentCGDisplay(self->displayLink, displayID);
        if( success2 == kCVReturnSuccess ){
            NSLog(@"movedToNewScreen CVDisplayLinkSetCurrentCGDisplay Success");
        }else{
            NSLog(@"movedToNewScreen CVDisplayLinkSetCurrentCGDisplay Fail");
        }

        int success = CVDisplayLinkSetCurrentCGDisplayFromOpenGLContext(self->displayLink, [self CGLContextObj], [[self openglPixelFormat] CGLPixelFormatObj]);
        if(success==kCVReturnSuccess){
            NSLog(@"movedToNewScreen CVDisplayLink Success");
        }else{
            NSLog(@"movedToNewScreen CVDisplayLink Fail");
        }
    }
}


This is a dictionary containing the attributes of the receiver's screen. For the list of keys you can use to retrieve values from the returned dictionary, see Display Deviceâ€”Descriptions.

In addition to the display device constants described in NSWindow, you can also retrieve the CGDirectDisplayID value associated with the screen from this dictionary. To access this value, specify the Objective-C string @"NSScreenNumber" as the key when requesting the item from the dictionary. The value associated with this key is an NSNumber object containing the display ID value. This string is only valid when used as a key for the dictionary returned by this method.

	1x 120 Hz
		3024 x 1964
		3024 x 1890
		2704 x 1756
		2704 x 1690
		2560 x 1600
		2294 x 1490
		2294 x 1432
		2048 x 1330
		2048 x 1280
		1920 x 1200

cmake -G Xcode ..



	void flip(int frame) {
		SDLFrame& sdlFrame = frames[frame];
		SDL_Window* window = sdlFrame.window;

		//		SDL_Renderer* r = sdlFrame.renderer;
		//		SDL_Surface *surface=sdlFrame.surface;
		//		int g = frameCount++ % 100;
		//		Uint32 c = SDL_MapRGB(surface->format, 44, g, 77);
		Uint32 c = 0xffff00ff;
		int x = 10 + frameCount % 40;
		drawQuad(frame, { x * 10,10,40,40 }, c);
		//		SDL_FillSurfaceRect(surface, NULL, c);
		//		SDL_RenderPresent(r);
		SDL_UpdateWindowSurface(window);
	}


	int test2() {
		SDL_Window* window = NULL;
		Uint32 flags = SDL_WINDOW_FULLSCREEN | SDL_WINDOW_OPENGL;	// | SDL_WINDOW_HIGH_PIXEL_DENSITY;

		int w = 1280;
		int h = 960;
		int hz = 75;

		window = SDL_CreateWindow("plainview", w, h, flags);
		//		"hello_sdl2", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,1024,768,SDL_WINDOW_SHOWN);
		if (window == NULL) {
			fprintf(stderr, "could not create window: %s\n", SDL_GetError());
			return 1;
		}

		SDL_Surface* screenSurface = NULL;
		screenSurface = SDL_GetWindowSurface(window);
		int frameCount = 0;

		bool running = true;
		while (running) {			
			int count = (frameCount++) % 100;
			int g = count*2;
			SDL_FillSurfaceRect(screenSurface, NULL, SDL_MapRGB(screenSurface->format, 44, g, 77));
			SDL_UpdateWindowSurface(window);
			SDL_Event event;
			if (SDL_WaitEventTimeout(&event, 5)) {
				switch (event.type) {
				case SDL_EVENT_KEY_DOWN:
					running = false;
					break;
				}
			}
			SDL_Delay(5);
//			std::cout << "." << std::endl;
		}
		SDL_DestroyWindow(window);
		SDL_Quit();
	}

//		SDL_Renderer *r= sdlFrame.renderer;
//		int ok = SDL_RenderClear(r);
//		SDL_Renderer* r = sdlFrame.renderer;
//		const SDL_FRect rect = { dest.x,dest.y,dest.w,dest.h };
//		int ok = SDL_RenderRect(r, &rect);
//		int g = frameCount++ % 100;
//		Uint32 c = SDL_MapRGB(surface->format, 44, g, 77);

//		SDL_Renderer* r = sdlFrame.renderer;
//		const SDL_FRect rect = { dest.x,dest.y,dest.w,dest.h };
//		int ok = SDL_RenderRect(r, &rect);
//		int g = frameCount++ % 100;
//		Uint32 c = SDL_MapRGB(surface->format, 44, g, 77);

//		SDL_Renderer* r = sdlFrame.renderer;
//		SDL_Surface *surface=sdlFrame.surface;
//		int g = frameCount++ % 100;
//		Uint32 c = SDL_MapRGB(surface->format, 44, g, 77);
//		SDL_FillSurfaceRect(surface, NULL, c);
//		SDL_RenderPresent(r);


git submodule add https://github.com/glfw/glfw
git submodule add https://github.com/libsdl-org/SDL


plainview 0.1
SDL 3.0.0
GLFW 3.4.0 Win32 WGL Null EGL OSMesa VisualC
SDL U28E590 0,0,3840,2160
        1x 29.97 Hz
                3840 x 2160
                2560 x 1600
                2048 x 1536
        1x 30 Hz
                3840 x 2160
                2560 x 1600
                2048 x 1536
        1x 56 Hz
                800 x 600
                720 x 576
                720 x 480
        1x 59.94 Hz
                2560 x 1440
                1920 x 1440
                1920 x 1200
                1920 x 1080
                1768 x 992
                1680 x 1050
                1600 x 1200
                1600 x 1024
        1x 60 Hz
                3840 x 2160
                2560 x 1600
                2560 x 1440
                2048 x 1536
                1920 x 1440
                1920 x 1200
                1920 x 1080
                1768 x 992
                1680 x 1050
                1600 x 1200
                1600 x 1024
                1600 x 900
                1440 x 900
                1366 x 768
                1360 x 768
                1280 x 1024
                1280 x 960
                1280 x 800
                1280 x 768
                1280 x 720
                1176 x 664
                1024 x 768
                800 x 600
                720 x 576
                720 x 480
                640 x 480
        1x 70 Hz
                1024 x 768
        1x 72 Hz
                800 x 600
                720 x 576
                720 x 480
                640 x 480
        1x 75 Hz
                1280 x 1024
                1280 x 960
                1152 x 864
                1024 x 768
                800 x 600
                720 x 576
                720 x 480
                640 x 480
GLFW Generic PnP Monitor 0,0,3840,2064
        1x 29 Hz
                2048 x 1536
                2560 x 1600
                3840 x 2160
        1x 30 Hz
                2048 x 1536
                2560 x 1600
                3840 x 2160
        1x 56 Hz
                720 x 480
                720 x 576
                800 x 600
        1x 59 Hz
                1600 x 1024
                1768 x 992
                1680 x 1050
                1600 x 1200
                1920 x 1080
                1920 x 1200
                1920 x 1440
                2560 x 1440
        1x 60 Hz
                640 x 480
                720 x 480
                720 x 576
                800 x 600
                1176 x 664
                1024 x 768
                1280 x 720
                1280 x 768
                1280 x 800
                1360 x 768
                1366 x 768
                1280 x 960
                1440 x 900
                1280 x 1024
                1600 x 900
                1600 x 1024
                1768 x 992
                1680 x 1050
                1600 x 1200
                1920 x 1080
                1920 x 1200
                1920 x 1440
                2048 x 1536
                2560 x 1440
                2560 x 1600
                3840 x 2160
        1x 70 Hz
                1024 x 768
        1x 72 Hz
                640 x 480
                720 x 480
                720 x 576
                800 x 600
        1x 75 Hz
                640 x 480
                720 x 480
                720 x 576
                800 x 600
                1024 x 768
                1152 x 864
                1280 x 960
                1280 x 1024
